# -*- mode: org; coding: utf-8; -*-
#+TITLE:              面试准备 - Java 高级技术岗位方向
#+AUTHOR:         Junahan
#+EMAIL:             junahan@outlook.com 
#+DATE:              2018-05-12
#+LANGUAGE:    CN
#+OPTIONS:        H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:        TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT:   view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+LICENSE:         CC BY 4.0

* 摘要
本文根据作者多年的从业经验，包括面试和被面试的经历，汇总的有关知识要点，主要是适用于 Java 高级技术岗位方向，除了 Java 相关的章节外，其他章节也适用于其他编程相关的高级职位方向。本文主要包含 Java、SQL、算法基础、软件复用和设计模式、高并发架构设计、安全、DevOps、优化等主题。

希望该文能够对你有所帮助。如果有你有意补充本文遗漏的主题或者发现本文的任何谬误，欢迎联系我 - junahan@outlook.com。

* Java
** 准备工作
- 安装 JDK8
- 准备好常用的编辑器或者代码浏览器，主要用于浏览 JDK 源代码。Emacs 用户，可以参阅 [[https://github.com/junahan/junahan-emacs/blob/master/docs/java-ide.org][Emacs Java IDE 配置]]。
- 下载 JDK 源代码，这里以 JDK8 为例，在终端运行 =hg clone http://hg.openjdk.java.net/jdk8/jdk8/jdk/= 命令克隆 JDK8 源代码。

*** 问题示例
#+BEGIN_EXAMPLE
Q. 你是否阅读过 JDK 的源代码？
A. 是的，我部分阅读过 OpenJDK8 源代码。
#+END_EXAMPLE

** Java 基础
- Object 类的方法继承和重写 - =eques=, =hashCode=, =toString=
- 变量和对象的创建和销毁
- 变量的生命周期 - 全局、局部和静态
- 对象的生命周期 - 全局、局部和静态

** Java Container API
Java Container 从最早期的 Array, Vector, HashTable 发展和完善到 List, HashMap，Queue，以及各类适用于并发场合的容器版本，并完整的支持范型。空闲的时候，读一读 JDK 源码有关容器的实现，有助你对数据机构和算法的理解。选择容器的时候，请注意使用的场合和要求，在多线程环境下，特别要留意线程安全问题。
- Collections - Java 容器的静态工厂类，通过该静态工厂，可以创建各类你所需要的常用容器
- List - 各种线性序列容器供君选择
- Map - 相信大家使用较为频繁的就是 HashMap 了, HashMap 并非线程安全的实现，如果需要线程安全的实现，更换为 =Collections.synchronizedMap(new HashMap(...))= 。另外需要注意的是，要是你的类能够高效的作为 Map 的 Key 使用，需要正确的覆盖 =hashCode= 方法。HashMap 在实现上默认使用 =Bucket Hash Table=, 在元素数量增长到一定情形下，会切换使用 =Tree Node= ，元素数量减少后，还会切换回去。
- PriorityQueue - 使用数组实现，实质上是一个最小值堆（Balance binary min-heap) 

** Java Thread and Concurrent API
*** Java 线程原语
- Object 类的线程基础设施 - 每个 Java 引用对象 (继承自 Object ) 都有一个与之关联的隐含的互斥 (Mutex or Monitor) ，可以使用 =suynchronized= 语句来锁定和解锁，除此之外，每个引用对象还有一个与之关联的等待设置 (Wait Set) ，等待设置通过 wait, notify, notifyAll 方法原子操作。每个 Java 类本身 (如 Foo.class) 也有和引用对象同样的隐含互斥和等待设置，这可以用来保护静态共享资源
- 互斥 (Mutex) 和 =synchronized= 关键字 - =synchronized= 关键字使用互斥，并自动加锁和解锁，可作用于方法级别和代码块级别
- 条件变量 (Condition Variable) 和 wait/notify/notifyAll 配合使用
- =volatile= 关键字 - 是另外一个有关线程安全的机制，该关键字可用于保护共享变量而无需加锁，Java 内存模型确保该变量的值在多线程环境下的一致性
- ThreadLocal - 理解 Thread Local 的基本原理，很简单的方法是看一看 =ThreadLocal= 类的源代码和  JDK 文档 - 实质上它用 Map 数据结构实现
- 如何安全而优雅的结束线程 - 原则是不要尝试结束线程，只有线程自己知道该如何退出，如设置检查点，使用 =stop= 变量
- Java 内存模型 - 由 JSR-133 规范定义，[[http://www.cs.umd.edu/~pugh/java/memoryModel/][JSR-133 The Java Memory Model]] 仍然维护 JSR-133  的相关信息（JSR-133 规范完成后，相关内容被整合进[[https://docs.oracle.com/javase/specs/jls/se8/html/index.html][ Java 语言规范]]) ，[[http://gee.cs.oswego.edu/dl/jmm/cookbook.html][The JSR-133 Cookbook for Compiler Writers]] (by Doug Lea) 也是一份值得阅读的文章 (你不一定要去写编译器) 

*** Concurrent API
Concurrent 包提供了 Java 多线程编程方便且容易使用的 API，包括各种用于多线程环境的容器、Thread Pool、支持原子操作的常用基本类型替代版本，以及锁和条件变量等多线程基础设施。
- =concurrent.atomic= - 该包提供了原始类型（如Integer, Boolean, Long等）相应的支持原子更新操作的新类型。使用方法简单明了。
- =concurrent.locks= - 该报提供了锁 (Lock) 和条件变量 (Condition) 相关的基础设施，设计上用于取代 Synchronized 关键字，wait, notify, notifyAll 以提供更加灵活且易于使用的 API。
- =concurrent= - 该包提供了各种线程安全的容器类型、线程池、线程执行和调度基础设施。 =Executors= 类是静态工厂类，可用于线程池创建、 =Callable= 构造 (可从 =Runnable=, =Action= 等类型转换) 、Executor 和 ExecutorService 对象创建，使这些线程基础设施的构造工厂。

*** Amdahl's law
有关并行加速的上限定律，该定律指出，事实上，很多序列化工作负载是无法从并行中获得性能加速。有关该定律的细节，请参阅 [[https://en.wikipedia.org/wiki/Amdahl%2527s_law][Amdahl's law]]。

*** 问题示例
#+BEGIN_EXAMPLE
Q. 请说说唤醒一个 wait 线程的几种方法？
A. 1，其他线程调用 notify 方法且该线程被选中唤醒；
     2，其他线程调用 notifyAll 方法；
     3，其他线程 interrupts 该线程；
     4，该线程 wait 方法调用指定的 timeout 时间（不为 0）到期;
     5，该线程将 wait 方法调用嵌套在一个循环中，从而可以自己唤醒自己；
#+END_EXAMPLE

#+BEGIN_SRC java
  public class Foo {
      static int count = 0;
      Object o = new Object();
      
      public void inc(int l) {
          synchronized(o) {
              count = count + 1;
          }
      }
  }
#+END_SRC
#+BEGIN_EXAMPLE
Q. 查看以上代码，请说明该代码是否能够在多线程环境下有效的保护 count 变量？
A. 答案是不能，修改方法：
1.  将 Object o = new Object() 语句去掉，使用 synchronized(Foo.class) { ... } 来保护静态变量
2.  将 Object o = new Object() 语句去掉，并去掉 synchronized(o) 语句，修改 static int count = 0 语句为 static volatile count = 0
#+END_EXAMPLE
#+BEGIN_EXAMPLE
Q. 简单的说一说，如果由你来设计实现 Thread Local，你如何做？
A. 等等，让我去看看 JDK 的源代码 ......
#+END_EXAMPLE
** Java 安全框架和 API 
Java 安全框架通过安全提供者机制支持可插入安全服务，并通过一组一致的 API 接口为安全应用开发提供便利。支持多种密码学算法（包括消息摘要、对称和非对称加密，秘钥协商等）支持，PKI 基础设施，认证，授权和资源访问控制，也支持 SSL/TSL 安全通讯通道。经过不断的丰富和发展，可以为应用程序安全开发提供完整的安全框架服务。
- Cryptography (JCE) - 密码学算法支持
 - 随机数生成器 - NativePRNG, PKCS11, SHA1PRNG
 - 消息摘要算法 - MD2, MD5, SHA, 
 - 数字签名算法 - RSA, DSA, ECDSA
 - 对称加密 (both for bulk and stream) - Blowfish, DES, DESede, AES, RC2, RC4
 - 非对称加密 - DH (Diffie-Hellman), RSA, DSA, ECC
 - Key Agreement Algorithms - DH , Elliptic Curve Diffie-Hellman (ECDH) 
 - 秘钥生成 - AES, Blowfish, DES, HmacMD5, HmacSHAx
 - 秘钥对生成 - DSA, RSA, EC, DH
 - 消息验证码 (MACs) - HmacMD5, HmacSHA1/224/256/384/512
- Public Key Infrastructure (PKI) - 
 - Keystore - 用于存储秘钥和证书，支持 PKCS11, PKCS12 Keystore 类型，也包含一个 JKS (Java Key Store) 和 DKS (Domain Key Store) 类型
 - Keytools - 用于创建和管理 Keystore
 - X.509 digital certificates
 - Certificate Revocation Lists (CRLs)
- Authentication (JAAS) - 通过一个认证框架提供可插入认证模块支持，通过 LoginContex 为客户端提供统一的访问入口，通过 LoginModule 接口提供认证模块，如 Krb5LoginModule， JndiLoginModule (LDAP)， KeyStoreLoginModule 等。
- Security Communication (JSSE)
 - SSL/TSL
 - SASL (Simple Authentication and Security Layer) - 
 - GSS-API (Generic Security Service Application Programming Interface) - aka. JGSS
- ACL -  用于保护敏感资源 (如文件，数据库)，以及敏感代码 (如类方法等)。通过 =java.lang.SecurityManager= 类来检查权限和实施访问控制，通过安全策略 (Security Policy) 来管理和配置授权。
- XML Signature - 产生和验证 XML 签名
- Security Provider - 通过一个提供者框架机制，允许加载不同提供者实现的安全服务。

** Java 内存管理
- 区分几个概念 - JVM 栈 (JVM Stack), 方法区域 (Method Aerea), 本地方法栈 (Native Method Stack), 帧 (Frame) 和方法调用过程中栈的相关操作，方法的局部变量被存放在线程的栈帧内 (Frame) ，不会被其他线程访问
- 堆内存 (Heap Memory) - Heap 由 GC 管理并在不同 JVM Thread 间共享。Heap 用于存储类实例和数组

** GC
- 了解 GC 对堆内存 (Heap Memory) 管理的细节，如 Heap Memory Layout 以及 GC 的工作原理等会有所帮助
- 你不能控制 GC 何时开始收集垃圾，垃圾收集期间，可能会导致应用响应延迟 (Latency，应用暂时停止响应)
- GC 的性能会影响系统的吞吐量 (Throughput) ，尤其是在大型服务系统中（10% 的 GC 工作负载会在有 32 个处理器系统上导致高达 75% 系统吞吐量的损失）。因此，GC 的选择和调优会变得很有必要。GC 的调优是建立在吞吐量和延迟的相对平衡上。相关详情，请参阅 [[https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html][HotSpot Virtual Machine Garbage Collection Tuning Guide]]

** 问题示例
*** 示例 I
基于如下 Java 代码回答问题。
#+BEGIN_SRC java
  class ClassA {
      public Integer doSomething() {
          int i = 0;  //@1
          ClassB cb = new ClassB();  //@2
          Integer r = cb.doAnything(i);  //@3
          return r;  //@4
      }  

      public void static main(String[] args) {
          ClassA ca = new ClassA();
          Integer r = ca.doSomething();
          //...
      }
  }

  class ClassB {
      public Integer doAnything(int seed) { 
          // do anything here.
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
Q. 请分别简单的回答当程序执行到@1, @2, @3, @4 行结束处，Java 内存堆栈 (Stack)，堆 (Heap) 分别发生了什么？
A. @1 处，变量 i 被初始化并压入 doSomething 方法栈帧；
     @2 处，在堆中创建并初始化 ClassB 实例并将该实例的引用变量 cb 压入堆栈；
     @3 处，为 cb.doAnything 方法调用创建栈帧，执行该方法并把返回结果 r 压入 doSomething 方法操作数栈；
     @4 处，弹出 doSomething 方法栈帧，完成对该栈帧内存的回收，返回结果的值压入 main 方法操作数栈；

Q. 如果由你来设计一个 Java 垃圾处理器，当 doSomething 方法调用结束后，有何方法可以高效的回收 ClassB 实例内存？（这里请允许面试官去喝杯咖啡，你先想一想。）
A. 先跳过吧，让我好好想一想，随后回答您 ......
#+END_EXAMPLE

* SQL
1. SQL basic principle
2. SQL standard statement
3. Index and Performance
 - Index primary/foreign key
 - Index frequency usage column in where sub statement
 - Index unique column
4. RDBM design normalization
 - 1NF - Eliminate repeating groups in individual tables; Create a separate table for each set of related data; Identify each set of related data with a primary key. 
 - 2NF - 1NF + every non-prime attribute of the relation is dependent on the whole of every candidate key.
 - 3NF - 2NF + all the attributes in a table are determined only by the candidate keys of that relation and not by any non-prime attributes. 3NF is designed to minimize storage costs. 3NF data modeling was ideal for OLTP application.

* 数据结构和算法分析
了解一些基本的数据结构，基础算法和算法分析。

** 数据结构
- List - Array, Sequential List, Linked List, Stack, Queue
- Binary Tree - Full Binary Tree, Complete Binary Tree, Balance Binary Heap - 
- Tree - 树形数据结构被用于大型数据库索引。如 B/B+树等。
- Graph - 

** 算法分析
*** 排序算法
记住一个事实 - 排序算法的最差和平均时间代价为 T(n*long(n))。

排序涉及到比较操作和交换操作，因此在分析的时候要考虑到两种操作的时间代价，有的排序算法要求的交换次数比其他排序算法多。
- 三种时间代价均为 T(n^2) 的排序算法 - 插入排序、起泡排序和选择排序
- Shell 排序的思想，利用插入排序最佳时间代价 T(n) 的特性，通过将序列递归分组并使用插入排序对分组分别排序的方法，将时间平均时间代价降低为 T(n^1.5)
- 快速排序使用分治法的思想，通过选择一个轴值将带排序序列一分为二，并将小于轴值的结点移动至轴值左侧，大于轴值的结点移动至轴值的右侧，然后分别对分割后的两个子序列使用相同的快速排序方法，通过递归的方法，直至剩下一个元素为止。快速排序平均时间代价是 T(n*log(n))，但最坏情形下是 T(n^2)，只不过最坏情况通常出现机会比较小。
- 归并排序仍然使用分治法的思想，将带排序序列分成两个等长的序列，并对分别对两个等长序列进行排序，然后合并两个序列，通过递归的方法，直至子序列长度为 1 为止。归并排序平均时间代价和最坏时间代价均为 T(n*log (n))。
- 堆排序，使用堆数据结构对带排序序列进行排序，该排序算法的最优/最差/平均时间代价均为 T(n*log(n))。

*** 检索算法
- 对一个没有排序的序列进行检索的平均和最差时间代价是 T(n)。
- 对一个有序序列进行检索可以使用二分法和字典检索方法。
- 集合检索是一种特殊情况，用于确定一个值是不是某一个集合中的元素。通过引入适当的索引可以很好的解决该类问题，例如，用于检索文档的位向量方法，倒排索引，以及如 [[https://en.wikipedia.org/wiki/Bloom_filter][Bloom Filter]] 索引。
- 散列方法，散列方法高速有效，但无法适用于范围搜索以及顺序访问的情形。

*** 索引
- 线性索引 - 简单的线性排序索引，问题在于无法高效的应对数据更新的情形，适用于静态数据
- 散列索引 - 基于散列方法的索引，不适用于范围搜索以及需要顺序访问的情形
- 树形索引 - 树形索引技术一般被应用于大型数据库索引，如 B/B+ 树形索引。B/B+ 树索引的检索、插入和删除记录的渐近时间代价是 T(long(n))。

* 软件复用和设计模式
** 软件复用方式
- 继承 (Inherit) - 面向对象的复用模式之一，通过类的继承结合多态实现复用。
- 设计模式 (Design Pattern) - 面向对象的复用模式，利用面向对象语言的特性，总结重复出现的良好设计并命名和归类以便于交流。
- 组合 (Component) - 更为普遍的软件复用方式，不仅仅局限于面向对象的编程。
- [[https://en.wikipedia.org/wiki/Generic_programming][范型编程 (Generic)]] - 一种计算机编程风格，类型被参数化并允许在需要的时候指定类型并初始化，从而使得算法和功能可以适用于多种类型且避免为每种类型分别编码。如 C++ 的容器库和 Java 的容器库。
- [[https://en.wikipedia.org/wiki/Aspect-oriented_programming][面向切面编程 (AOP)]] - 通过定义一个切面的方式，为已有的代码添加额外的行为而无需修改已有代码。
- 库和框架 - 组织良好的一系列可复用软件组件。

** 面向对象
- 继承 - isA 和 asA 的区别
- 封装 - 隐藏数据和实现，控制变量和方法的可见范围
- 多态 - 也称为后期绑定的基本概念和运行原理

** 设计模式
Design patterns were originally grouped into the categories: creational patterns, structural patterns, and behavioral patterns, and described using the conceptions of delegation, aggregation, and consultation. Another classification has also introduced the notion of architectural design pattern that may be applied at the architecture level such as MVC pattern.

- 重点了解几个常用的[[https://en.wikipedia.org/wiki/Software_design_pattern][设计模式]] , 如 Factory, Builder, Adapter, Visit 等
- 对于[[https://en.wikipedia.org/wiki/Concurrency_pattern][并发模式]], 如 Lock, Thread Pool, Scheduler, Thread-local 等，看看 Java Concurrent 的设计，基本也就有了
- 对于[[https://en.wikipedia.org/wiki/Architectural_pattern][架构风格和模式]] , 主要了解 [[https://en.wikipedia.org/wiki/Model-view-controller][MVC]] , DI, AOP 等

* 高并发系统架构
1. Challenge - high concurrency, high availability, low latency
2. Horizontal Scalability - meet high concurrent challenge
 - AFAP stateless service
 - No dependences in same layer (Horizontal)
 - Leverage lower layer distribution cache service for stateful session context - move state from front layers to lower layer dedicate system
 - Automation deployment
3. Low latency - 快速响应用户请求，和高并发不同，这个指标强调的是用户的响应时间，需要在纵向上进行端到端的优化

* 系统安全
建议参阅 OWASP 有关安全的指引，例如 OWASP Top 10 项目所列举的一些有关安全威胁，OWASP 也提供详细的有关 Web、Mobile 及其他方面有关安全的指引。

** OWASP Top 10 2017
- A1 注入 :: 将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如 SQL 注入、NoSQL 注入、OS 注入和 LDAP 注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预 期命令或访问数据。
- A2 失效的身份认证 :: 通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。
- A3 敏感数据泄漏 :: 许多 Web 应用程序和 API 都无法正确保护敏感数据，例如：财务数据、医疗数据和 PII 数据。攻击者可以通过窃取或修改未加密的数据来试试信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易收到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。
- A4 XML 外部实体 (XXE) :: 许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。
- A5 失效的访问控制 :: 未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的账户、查看敏感文件、修改其他用户的数据、更改访问权限等。
- A6 安全配置错误 :: 安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云 存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所 有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。
- A7 跨站脚本 (XSS) :: 当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器 中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。
- A8 不安全的反序列化 :: 不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括:重播攻击、注入攻击和特权升级攻击。
- A9 使用含有已知漏洞的组件 :: 组件(例如:库、框架和其他软件模块)拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组 件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。
- A10 不足的日志记录和监控 :: 不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超过 200 天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。

** OWASP Mobile Top 10 2016
- M1 平台使用不当 :: 这个类别包括平台功能的滥用，或未能使用平台的安全控制。它可能包括 Android intent 、平台权限、TouchID 误用、密钥链 (KeyChain) 、或是移动操作系统中的其他一些安全控制。
- M2 不安全的数据存储 :: 这个新的类别是《2014 年版十大移动安全威胁》中 M2 和 M4 的组合。这个类别包括不安全的数据存储和非故意的数据泄漏。
- M3 不安全的通讯 :: 这个类别包括不健全的握手通讯过程、SSL 版本的不正确使用、脆弱协议、敏感信息的明文传输，等等。
- M4 不安全的身份验证 :: 这个类别包括对终端用户身份验证或坏的会话管理的一件。包括：
 - 当被要求时，没有对所有用户进行身份识别。
 - 当被要求是，没有保持对用户身份的确认。
 - 会话管理中的漏洞。
- M5 加密不足 :: 代码使用加密技术对敏感信息资产进行加密。然而，加密技术的应用在某种程 度上是不足的。需要注意的是，任何与 TLS 或 SSL 有关的内容调整至 M3 中。此外，如果应用程序在它应当使用加密技术时而没有成功使用，该类问题可能属 于 M2。本类别是在尝试使用加密技术时，却又没有成功使用的问题。
- M6 不安全的授权 :: 这个类别包括任何失败的授权行为 ( 例如:在客户端的授权决策、强迫浏览等。) 。它有别于身份验证问题 ( 例如:设备注册、用户标识等 ) 。
- M7 客户端代码质量问题 :: 这个类别曾经是“通过不可信的输入做出安全决定”，是我们较少使用的类别 之一。这将包括全部的移动客户端代码级别开发问题。
- M8 代码篡改 :: 本类别包括二进制修补、 本地资源修改、 方法钩用、方法调整和动态内存修改。
- M9 逆向工程 :: 本类别包含对核心二进制代码的分析，以确定它的源代码、 库文件、 算法和 其他资产。比如:IDA Pro、Hopper、 otool 和其他二进制检验工具，使攻击者能洞察到应用程序内部的工作原理。这可用于在应用程序中发现其他漏洞， 并可揭露有关后端服务器、加密常数、密码以及知识产权的信息。
- M10 无关的功能 :: 通常，开发人员不会打算将隐藏地后门程序功能或其他内部开发安全控件发布到生产环境中。例如:开发人员可能在一个混合应用程序中无意包含了一个作 为注释的密码。另一个例子包括在测试阶段禁用了双因子身份验证。

** Security Penetration Testing
- 一般而言，由外部安全测试专家从外部进行安全渗透测试
- 测试案例基本上会遵循 OWASP 有关安全的指引
- 如果是针对有 Web 界面的应用，可以通过安全扫描工具自动执行测试
- 如果 Web 端服务只有 Restful 风格的 API (如今比较流行)，则需要手动测试
- 测试一般而言会导致脏数据入库甚至会可能会导致数据不一致情形，因此通常会在和生产环境相似的测试环境进行，但这会由于生产环境的不同配置导致生产环境可能存在潜在安全威胁。生产环境准备好，还没有投入正式使用前，可以做这样的测试，一旦生产环境投入使用，这类测试不宜在生产环境进行

** WEB Automation Test
- Selenium for web automation
- IBM Scanner

** Mobile Automation Test
- Appium - both for Android and iOS
- KeepItFunctional - for iOS
- Selendroid - for Android

* DevOps
基本指导思想 - 开发运维一体化，尽最大可能自动化构建、测试、部署，追求高质量快速产品交付。

** Dev
基本指导思想 - 采用敏捷开发模型，执行快速迭代过程，最大可能构建、测试自动化，追求高质量快速产品交付。

1. 开发可维护代码 - 代码风格、注释、文档和重构
2. Peer code review
3. Automation Unit Test - coverage >= 80%
4. Nightly build and automation unit and integration testing - Using Jenkins
5. Automation integration testing - for web and mobile App

** Ops
基本指导思想 - 无缝对接开发，自动化部署，有效监控，快速事件响应。

1. Automation deployment
 - Using script for first stage
 - Planning move to Chef + Kubernetes + Docker
2. System health monitoring and alarm
 - Database
 - Cache server
 - RPC
 - Web
 - Machine level - CPU, Memory, Storage usage
3. 运维事件快速响应
 - 

** Tool Chain
- Code - code development and review, source code management tools, code merging - Git/Gitlab
- Build - continuous integration tools, build status - Jenkins/Maven/Gradle/Make
- Test - continuous testing tools that provide feedback on business risks - Unit/Selenium
- Package - artifact repository, application pre-deployment staging
- Release - change management, release approvals, release automation - 
- Configure - infrastructure configuration and management, Infrastructure as Code tools - Puppet/Chef/Docker/Kubernetes
- Monitor - applications performance monitoring, end–user experience

* 优化
优化是一个很宽泛的概念，在这里，我们特指团队或者组织，为特定产品或者服务，以特定目标为导向而采取措施的过程。例如，用户体验优化、业务功能优化、系统性能优化等。优化通常伴随着问题的发现和以目标为导向。

** 优化的指导性框架 - GMMF
1. Goal - 
 - KPI - Product Recommendation Performance, etc.
 - Find interesting - 
2. Matrix -
 - Page Conversion Rate
 - Page Residence Time
 - Order / Payment Rate
 - Activity User - by Day/Month
 - Revenue
3. Methodology - 
 - Data Collection - Access log, APP log, System log
 - Data Analysis - Statistic, ML
 - Compare matrix with different situation
 - Conclusion, Estimation
 - Measure - Page Layout, A/B testing
4. Feedback and Result - 
 - Data - logs, database data, etc.
 - Statistic Diagram - Heat Map, Distribution Diagram, ECHARTS
 - ML Mode - Tensorflow, Caffe
5. Challenge
 - Factors without data - fashion, competitor data, etc.
 - Data distribution is not stable - change with time, for example - fashion
 - Confusing the factors - Measure (what we take) itself change the result and the data what we collection including the confusing data. That lead to a risk - the result  deviate from under trues.

** 用户体验优化
- UI 布局
- 提升商品推荐系统的准确度和转化率
- 广告对用户体验的影响

** 业务过程优化
- 优化业务过程资源配备以快速响应用户需求
- 优化运维监控事件处理以快速发现和响应告警事件

** 系统性能优化
- 系统可用性 - 以可用性为目标，优化系统的可用性配置
- 系统并发吞吐量 - 以并发吞吐量为目标，优化系统高并发条件下的性能
- 快速响应 - 以快速响应用户请求为目标，优化系统的性能

** End-to-end Tracking System

*** 什么是 End-to-end Tracking System
End-to-end Tracking System 是指一套能够穿透业务系统前后端的业务日志及分析系统。其特点是能够有效的穿透整个业务系统，从最前端的业务开始一直到最后端的数据逻辑层。该系统能够带来的好处包括：
1. 能够有效的关联整个业务，为数据分析带来便利；
2. 有助于识别和发现系统问题；
3. 有助于识别和发现安全攻击；

*** 建立的方法
建立这样的一套系统并不容易，需要业务设计开发上的协调一致，通常发生的情形时，前段业务系统为用户的访问创建了一个唯一标示（例如访问令牌），而到后端的业务日志中却并不记录该标示，从而无法使用该标示穿透整个业务系统日志记录。
- 协调整个前后端业务系统使用一个唯一标示（如访问令牌），并包含该唯一标示进入业务日志系统中，技术上可以是需要手动将唯一标示编码进入业务日志 (如提供统一的用于 Tracking System 库)，也可以是自动注入的方式加入业务日志系统（如使用 [[https://en.wikipedia.org/wiki/Aspect-oriented_programming][AOP]] 技术提供 Tracking System 注入切面）。
- 自动收集 Tracking System 日志并导入一个日志分析系统进行分析
- 提供 Tracking System 数据访问用户接口，为数据分析员和相关人员提供一致的访问入口

*** 技术和工具
1. Storm - http://storm.apache.org.
2. Logstash - https://www.elastic.co/products/logstash.
3. ML 技术，可以对 Tracking Log 建立 ML Model 进行训练和预测。

* 参考文献
1. W3school SQL 教程,  http://www.w3school.com.cn/sql/.
2. JDK API Document, https://docs.oracle.com/javase/8/docs/api/index.html.
3. OpenJdk Home, http://openjdk.java.net/projects/jdk8/.
4. HotSport VM Garbage Collection Tuning Guide, https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html.
5. Java Language Specification for JSE8, https://docs.oracle.com/javase/specs/jls/se8/html/index.html.
6. JSR-133 Cookbook, http://gee.cs.oswego.edu/dl/jmm/cookbook.html.
7. Java 多线程编程, [美] Bil Lewis, Daniel J. Berg 著，关欣、史宗海等译，电子工业出版社出版，2000.
8. Amdahl's law, https://en.wikipedia.org/wiki/Amdahl%27s_law
9. 数据结构与算法分析（Java 版本）, [美] Clifford A. Shaffer 著，张铭、刘晓丹译，电子工业出版社出版，2001.
13. Software Design Pattern, https://en.wikipedia.org/wiki/Software_design_pattern.
15. Architectural Pattern, https://en.wikipedia.org/wiki/Architectural_pattern.
17. Design Patterns, https://www.oodesign.com.
19. OWASP Top 10, https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project.
21. OWASP Mobile Top 10, https://www.owasp.org/index.php/Mobile_Top_10_2016-Top_10.
23. OWASP China Projects, http://www.owasp.org.cn/owasp-project.
25. DevOps, https://en.wikipedia.org/wiki/DevOps.
27. aosd.net, http://aosd.net.
29. Aspectj Home, http://www.eclipse.org/aspectj/.
31. Aspect-oriented programming, https://en.wikipedia.org/wiki/Aspect-oriented_programming.
33. AOP (面向切面编程), https://baike.baidu.com/item/AOP/1332219.
35. Storm, http://storm.apache.org.
37. Logstash, https://www.elastic.co/products/logstash.
39. Bloom Filter, https://en.wikipedia.org/wiki/Bloom_filter.

#+BEGIN_QUOTE
本作品采用[[http://creativecommons.org/licenses/by/4.0/][知识共享署名 4.0 国际许可协议]]进行许可。
#+END_QUOTE
